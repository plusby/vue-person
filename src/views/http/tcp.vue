<template>
  <div class="tcp-wrap">
    <pre>
      问题：一个tcp链接可以发多少个http请求？

      问题2：现代浏览器和服务器建立一个tcp连接之后是否会在一个http请求完成之后断开？什么情况下会断开？
        在http/1.0中，服务器发送完一个响应之后就断开了tcp连接，每次请求都要重新进行tcp连接，那么这样开销太大，
        因此有些服务器默认支持请求头中设置connect:keep-alive进行长连接，但是没有被写入标准；
        在http/1.1之后把connect:keep-alive写入标准，并且默认是开启的，因此每次请求都会保持长连接，除非手动
        设置请求头中的Connect:close;为关闭状态

        总结：默认情况下建立tcp之后请求一次http不会被断开，只有设置请求头中的Connect:close;为关闭状态才会在请求完成之后断开

      问题3：一个Tcp连接可以对应几个http请求？
        保持长连接可以发送多个http请求

      问题4：为什么有的时候刷新页面不需要重新建立ssl连接？
        因为设置了请求头Connect:keep-alive进行长连接，因此Tcp不需要重新建立连接，自然SSL也不需要重新连接

      问题5：浏览器对同一个host建立tcp连接的数量有没有限制？
        有限制，谷歌浏览器最多允许同一个host建立6个tcp连接，不同浏览器有不同的区别；

        如果可以使用http2那么就多路传输，如果只能使用http/1.1那么同一个host开启最大数量的Tcp链接，这些tcp链接在空闲的时候会被
        浏览器用来发送请求，如果全部都没有空闲，只能等待

      问题6：一个TCP连接中http请求可以一起发送一起得到响应？
        在http/1.1中单个的TCP连接在同一时刻只能接收和响应一个http请求(同一时刻不能处理多个请求)，虽然http/1.1规范中规定了Pipelining
        来解决这个问题，但是这个功能被浏览器所关闭；
        什么是Pipelining?
          一个持久连接中，客户端可以在同一时刻发送多个请求，接收到请求的服务端必须按照请求顺序进行响应；因为http/1.1是文本协议，没有办法
          根据响应的内容区分是哪个请求，因此只能顺序响应；
        Pipelining带来的问题：
          响应需要排队等待，因此现在浏览器是关闭这个功能的

        在http2中提供了multiplexing多路传输的特性，可以在同一个时刻完成多个http请求和响应

        总结: 在http/1.1中虽然提供了pipelining来解决这个问题，但是浏览器默认是关闭的，所以认为不可行，在http2中提供的multiplexing的特性，
              可以在同一tcp连接中并行请求

        在http/1.1中如何提高页面加载效率?
            建立多个tcp连接，或者一个tcp连接顺序处理多个请求

        

        

    </pre>
  </div>
</template>

<script>
export default {

}
</script>

<style>

</style>