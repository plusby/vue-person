(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["function1","home"],{"15e3":function(e,n,p){"use strict";p.r(n);var r=function(){var e=this,n=e.$createElement;e._self._c;return e._m(0)},t=[function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("div",[r("h1",[e._v("单页面首屏加载慢和SEO问题")]),r("p",[e._v("可以使用以下方案")]),r("h2",[e._v("1. prerender-span-plugin预渲染插件")]),r("p",[e._v("prerender-span-plugin预渲染插件，就是在打包的时候根据指定的路由，把路由对应的页面渲染为html输出， 那么指定多少路由打包的时候就输出多少html页面，生成了html页面相当于原生h5，浏览器直接从服务端获取 相应的html，从而降低了首屏的显示时间 ")]),r("h3",[e._v("原理：")]),r("p",[e._v("prerender-span-plugin是利用了Chrome推出的Puppeteer库，进行页面的爬取。Puppeteer是一个Node库， 默认为headless模式(无头模式)，在无需UI的情况下通过 DevTools 协议控制Chrome;在webpack构建阶段的 最后，在本地启动Puppeteer服务，然后根据指定的预渲染路由，将相应的页面输出到html文件中，并建立相应的目录 ")]),r("img",{attrs:{src:p("9aa9"),alt:"prerender-span-plugin"}}),r("h3",[e._v("使用:")]),r("p",[e._v("前提条件，vue的路由必须使用history模式")]),r("p",[e._v("安装")]),r("pre",{staticClass:"code"},[e._v("        cnpm i -D prerender-span-plugin\n    ")]),r("p",[e._v("配置webpack.config.js")]),r("pre",[e._v("        const PrerenderSPAPlugin = require('prerender-spa-plugin')\n        const Renderer = PrerenderSPAPlugin.PuppeteerRenderer\n        plugins: [\n            new PrerenderSPAPlugin({\n                staticDir: path.join(__dirname, 'dist'),  // 注意路径不能错\n                // indexPath: path.join(__dirname, '../dist', 'index.html'), \n                routes: ['/', '/summary','/babel','/performance','/postcss','/prerenderSpaPlugin'],\n                renderer: new Renderer({\n                    inject: {\n                        foo: 'bar'\n                    },\n                    headless: true, \n                    renderAfterDocumentEvent: 'render-active' \n                    // renderAfterElementExists: '.container', \n                    // renderAfterTime: 5000 \n                })\n            })\n        ]\n    ")]),r("p",[e._v("staticDir：预渲染之后文件输出目录")]),r("p",[e._v("indexPath: 静态模板页面")]),r("p",[e._v("routes: 预渲染的路由")]),r("p",[e._v("renderer: 渲染器")]),r("p",[e._v("inject: 像预渲染页面注入数据，默认挂在window.__PRERENDER_INJECTED对象上，可以通过window.__PRERENDER_INJECTED.foo在预渲染页面取值")]),r("p",[e._v("headless：是否是无浏览器窗口")]),r("p",[e._v("renderAfterDocumentEvent： 等到指定的事件触发之后再去进行预渲染")]),r("p",[e._v("renderAfterElementExists: 在指定元素渲染之后再去触发预渲染")]),r("p",[e._v("renderAfterTime: 指定时间之后进行预渲染")]),r("p",[e._v("配置main.js")]),r("pre",{staticClass:"code"},[e._v("        new Vue({\n            router,\n            store,\n            render: h => h(App),\n            mounted(){ // vue页面挂载之后进行预渲染 \n                document.dispatchEvent(new Event('render-active'))\n            }\n        }).$mount('#app')\n    ")]),r("h2",[e._v("缺点：")]),r("p",[e._v("1. 因为是根据路由生成html,所以对于动态的路由是不起作用")]),r("p",[e._v("2. 并且不能有同名路由，否则最终只生成一个对应路由的html")]),r("h2",[e._v("优化SEO")]),r("p",[e._v("通过vue-meta-info插件进行SEO优化，一般和prerender-span-plugin预渲染插件配合使用")]),r("h3",[e._v("原理：")]),r("p",[e._v("根据配置的metaInfo，会在相应的页面中动态的创建title、meta和link元素")]),r("h3",[e._v("使用：")]),r("p",[e._v("安装")]),r("pre",[e._v("        cnpm i -D vue-meta-info\n    ")]),r("p",[e._v("配置main.js")]),r("pre",[e._v("        import MetaInfo from 'vue-meta-info' \n        Vue.use(MetaInfo)  // 使用meta\n    ")]),r("p",[e._v("组件中使用")]),r("pre",[e._v("        export default {\n            metaInfo: {   // 使用vue-meta-info插件\n                title: '性能优化', // set a title\n                meta: [{                 // set meta\n                    name: '性能优化',\n                    content: '性能优化'\n                }],\n                link: [{                 // set link\n                    rel: '性能优化',\n                    href: this.href  // 动态配置\n                }]\n            }\n        }\n    ")]),r("p",[e._v("输出结果：")]),r("img",{attrs:{src:p("65cb"),alt:""}})])}],a={},l=a,s=p("e90a"),v=Object(s["a"])(l,r,t,!1,null,"a34291e2",null);n["default"]=v.exports},"20aa":function(e,n,p){"use strict";p.r(n);var r=function(){var e=this,n=e.$createElement;e._self._c;return e._m(0)},t=[function(){var e=this,n=e.$createElement,p=e._self._c||n;return p("div",[p("h1",[e._v("babel总结")]),p("h2",[e._v("原因：")]),p("p",[e._v("不同浏览器中对最新标准的es支持度不尽相同，相同浏览器的不同版本支持度也不相同，因此为了开发者能够使用最新的标准 语法去兼容所有主流浏览器，就出现了babel ")]),p("h2",[e._v("原理：")]),p("p",[e._v("babel和webpack、postcss一样，仅仅提供代码的分析，真正的转换是借助于插件完成")]),p("h3",[e._v("1.babel的安装")]),p("p",[e._v("安装两个库")]),p("p",[e._v("- @babel/core: babel的核心库，提供了编译时需要的所有api")]),p("p",[e._v("- @bale/cli: babel命令行工具")]),p("p",[e._v("npm i -D @babel/core @babel/cli")]),p("h3",[e._v("2. babel的使用")]),p("p",[e._v("- 按文件编译")]),p("p",[e._v(" babel 要编译的文件 -o 编译结果的文件")]),p("p",[e._v("- 按目录编译")]),p("p",[e._v(" babel 要编译的目录 -o 存放编译结果的目录")]),p("h3",[e._v("3. babel的配置")]),p("p",[e._v("babel和postcss一样，既有预设又有插件(预设就是一些常用的插件的集合)")]),p("p",[e._v("根目录创建一个.babelrc的文件，配置如下代码")]),p("pre",{staticClass:"code"},[e._v('        {\n            "presets": [],  // 预设\n            "plugins": []   // 插件\n        }\n    ')]),p("h2",[e._v(" bale预设")]),p("p",[e._v("常见的预设有@babel/preset-env,可以使用最新标准的es语法，无语安装额外的插件")]),p("p",[e._v("配置如下：")]),p("pre",{staticClass:"code"},[e._v('        {\n            "presets": [\n                "@babel/preset-env"\n            ]\n        }\n    ')]),p("p",[e._v("预设的使用需要指明兼容的浏览器")]),p("p",[e._v("和postcss一样，需要创建.browserslistrc文件来描述兼容的浏览器范围")]),p("pre",{staticClass:"code"},[e._v("        last 3 version\n        > 1%\n        no ie <= 8\n    ")]),p("p",[e._v("给预设设置自身的配置")]),p("p",[e._v("常见的配置有useBuiltIns,预设仅仅转换新的语法并不会对新的api进行转换,默认是false, 不能够使用最新的Esapi,可以设置为usage ")]),p("pre",{staticClass:"code"},[e._v('        {\n            "presets": [\n                ["@babel/preset-env",{\n                    "useBuiltIns": \'usage\',\n                    "corejs": 3  // 指定corejs的版本\n                }]  \n            ]\n        }\n    ')]),p("h2",[e._v("babel插件")]),p("p",[e._v("条件：比预设更加广泛，预设只能转换已经形成标准的es语法，对于提案的和最新的非标准Es语法还是不能够转换")]),p("p",[e._v("安装core-js和pregenerator-runtime插件可以使用最新的esapi,比如promise,asncy等")]),p("p",[e._v("core-js: 提供转换的api")]),p("p",[e._v("pregenerator-runtime: 用于转换generator迭代器")]),p("p",[e._v("1. babel-plugin-transform-remove-console")]),p("p",[e._v("打包的时候删除js中的所有console")]),p("pre",{staticClass:"code"},[e._v('        {\n            "plugins": [\n                [\n                "babel-plugin-transform-remove-console"\n                ]\n            ]\n            }\n    ')])])}],a={},l=a,s=p("e90a"),v=Object(s["a"])(l,r,t,!1,null,null,null);n["default"]=v.exports},2369:function(e,n,p){e.exports=p.p+"img/fb.d7f2e4bf.png"},5312:function(e,n,p){"use strict";p.r(n);var r=function(){var e=this,n=e.$createElement;e._self._c;return e._m(0)},t=[function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("div",[r("h1",[e._v("性能优化")]),r("p",[e._v("性能优化主要从以下几个方面入手：")]),r("p",[e._v("1. 构建性能")]),r("p",[e._v("2. 传输性能")]),r("p",[e._v("3. 运行性能")]),r("h2",[e._v("1. 构建性能")]),r("p",[e._v("构建性能是指:从打包开始到打包完毕或者从修改之后点击保存自动打包到页面的更新过程,整个过程都是在开发阶段进行的")]),r("p",[e._v("开发阶段优化了构建性能，可以大大的提高打包速度，从而提升了开发效率")]),r("p",[e._v("构建性能主要可以从以下几个方面考虑：")]),r("h3",[e._v("1.1 减少模块解析")]),r("p",[e._v("webpack中模块解析包括：抽象语法树分析、依赖分析、模块语法替换")]),r("h4",[e._v("不进行解析的模块会怎样？")]),r("p",[e._v("不做解析的模块，在loader处理之后就直接输出")]),r("p",[e._v("不做解析的模块，就少了上面的步骤，从而提升了打包速度")]),r("h4",[e._v("模块不需要解析的前提条件：")]),r("p",[e._v("模块中无其他依赖，如：jquery")]),r("h4",[e._v("配置如下：")]),r("pre",[e._v("        module.exports = {\n            //...\n            module: {\n                noParse: /jquery|lodash/,  // 不解析jqery和loadsh\n            }\n        };\n   ")]),r("h3",[e._v("1.2 loader方面的优化")]),r("h4",[e._v("1.2.1 让一些文件不使用loader")]),r("p",[e._v("减少loader的使用可以让一些文件不走loader转换，从而提高了打包速度")]),r("p",[e._v("有些文件或者第三方库本来就是loader转换之后的内容，所以就不需要loader再次解析")]),r("p",[e._v("eg:使用es5或者es3写了一个js文件，或者第三库本来就是使用es5写的代码，所以肯本不再需要 babel-loader进行转换，所以如下设置去除此文件的解析 ")]),r("pre",{staticClass:"code"},[e._v('      module.exports = {\n          module: {\n              rules: [\n                  {\n                      test: /\\.js$/,\n                      exclude: /node_modules/,  // 不解析node_modules\n                      //或\n                      // include: /src/,  // 指解析src文件夹下的文件\n                      use: "babel-loader"\n                  }\n              ]\n          }\n      }\n   ')]),r("h4",[e._v("1.2.2 缓存loader")]),r("p",[e._v("如果一些文件或者第三方库的内容在loader转换之后就不再改变，那么就可以在第一次编译之后进行缓存，以后的 每次打包都直接从缓存中获取 ")]),r("p",[e._v("eg: 对于jquery或者其他的第三方库")]),r("p",[e._v("使用cache-loader进行缓存")]),r("p",[e._v("安装")]),r("p",[e._v("npm install --save-dev cache-loader")]),r("p",[e._v("配置")]),r("pre",[e._v("    module.exports = {\n      module: {\n        rules: [\n          {\n            test: /jquery\\.js$/,\n            use: [ {\n              loader: 'cache-loader',\n              options:{\n                cacheDirectory: \"./cache\" // 指定缓存到的目录\n              }\n            }, 'babel-loader']\n          },\n        ],\n      },\n    };\n   ")]),r("p",[e._v("原理：")]),r("p",[e._v("匹配到文件之后，走loader的pitch方法，如果pitch方法发现有缓存就返回缓存中的代码，否则就走loader进行解析")]),r("img",{attrs:{src:p("9cbd"),alt:""}}),r("h4",[e._v("1.2.3 使用thread-loader给loader开启线程池")]),r("p",[e._v("把loader放到线程池中的线程中，以便提高构建速度")]),r("p",[e._v("放入线程池中的loader不能使用以下功能")]),r("p",[e._v("- 不能够使用webpack api")]),r("p",[e._v("- 无法访问webpack options")]),r("p",[e._v("- 无法使用自定义的plugin api")]),r("p",[e._v("注意，开启和管理线程需要消耗时间，在小型项目中使用thread-loader反而会增加构建时间")]),r("h4",[e._v("1.2.4 使用热更新")]),r("p",[e._v("热更新并不能降低构建的时间，可能会增加，但是减少了从更改代码保存到页面呈现的时间")]),r("p",[e._v("配置")]),r("p",[e._v("webpack.config.js")]),r("pre",{staticClass:"code"},[e._v("      const webpack = require('webpack');\n      module.exports = {\n        devServer:{\n          hot:true // 开启热更新\n        },\n        plugins:[ \n          // 使用热更新插件\n          new webpack.HotModuleReplacementPlugin()\n        ]\n      }\n   ")]),r("p",[e._v("入口文件中")]),r("pre",{staticClass:"code"},[e._v("      if(module.hot){ // 是否开启了热更新\n          module.hot.accept() // 接受热更新\n      }\n   ")]),r("p",[e._v("基本流程")]),r("p",[e._v("在没有使用热更新的时候，每次编译运行，webpack-dev-server都会执行localtion.reload重新加载页面，当使用了 热更新之后，webpack-dev-server会通过websocket把变更的代码主动推送到浏览器，然后通过注入的module.hot.accept进行接收， 然后通过HotModuleReplacementPlugin插件覆盖之前的模块并执行,所以热更新发生在代码运行期 ")]),r("p",[e._v("1. 修改一个或者多个文件中的代码")]),r("p",[e._v("2. webpack重新编译构建变更的模块,并通知HMR服务器进行更新")]),r("p",[e._v("3. HMR服务器通过websocket推送变更的模块到客户端")]),r("p",[e._v("4. 客户端通过注入的module.hot.accept接收到变更的内容")]),r("p",[e._v("5. HotModuleReplacementPlugin插件替换更新的模块进行执行")]),r("p",[e._v("6. 如果这些模块无法执行那么就直接执行localtion.reload重新加载页面")]),r("p",[e._v("注意：")]),r("p",[e._v("样式也可以进行热更新，但是通过mini-css-extract-plugin插件生成单独文件的样式不能进行热更新，因为 热更新发生在代码运行时期，而mini-css-extract-plugin插件生成单独css文件发生在构建时期,style-loader 的样式是可以进行热更新 ")]),r("h2",[e._v("2. 传输性能")]),r("p",[e._v("传输性能是指：文件从服务端传输到客户端的过程所需要的时间")]),r("p",[e._v("传输性能的提升可以缩短从页面请求到呈现的时间，可以从以下几个方面考虑：")]),r("p",[e._v(" - 总传输量：将所有的传输文件内容都加起来就是总传输")]),r("p",[e._v(" - 文件数量：需要传输的所有文件数量 ")]),r("p",[e._v(" - 浏览器缓存： 通过设置可以使得浏览器缓存传输的文件，被缓存的文件再次获取就会从缓存中获取")]),r("h3",[e._v("2.1 打包之后包太大可以分包处理")]),r("p",[e._v("解决的问题：")]),r("p",[e._v("一个文件包太大，导致网络响应很慢")]),r("p"),r("h4",[e._v(" 2.1.1 手动分包")]),r("p",[e._v("基本思路：")]),r("p",[e._v("- 单独的打包公共模块")]),r("p",[e._v("- 公共模块会被打包成动态链接库，并生成资源清单")]),r("p",[e._v("- 根据入口模块进行正常的打包")]),r("p",[e._v("- 在html页面中手动引入单独打包的公共模块")]),r("p",[e._v("步骤：")]),r("p",[e._v("1. 创建webpack.dll.config.js文件")]),r("p",[e._v("用于配置要单独打包的文件，暴露出变量名在全局中")]),r("pre",{staticClass:"code"},[e._v('      // 手动单独打包的配置\n      module.exports = {\n          mode: "production",\n          entry: { // 需要单独打包的文件\n              jquery: ["jquery"],\n              lodash: ["lodash"]\n          },\n          output: {\n              filename: "dll/[name].js",\n              library: "[name]" // 打包之后暴露的变量名\n          },\n          plugins: [\n              // 生成资源清单\n              new webpack.DllPlugin({\n                  path: path.resolve(__dirname,"dll","[name].manifest.json"), // 资源清单保存的位置\n                  name: "[name]" // 资源清单中，暴露的变量名\n              })\n          ]\n      }\n   ')]),r("p",[e._v("2. html页面手动引入单独的打包文件")]),r("pre",{staticClass:"code"},[e._v("     "),e._v("\n     "),e._v("\n   ")]),r("p",[e._v("3. webpack.config.js中设置clean-webpack-plugin插件")]),r("p",[e._v("如果使用了clean-webpack-plugin这个插件就需要重新配置，防止每次打包都清空了单独打包的文件")]),r("pre",{staticClass:"code"},[e._v("      plugins: [ // 插件\n        new CleanWebpackPlugin({ // 打包前清空目录\n            // 排除掉dll目录本身和它里面的文件\n            cleanOnceBeforeBuildPatterns: [\"**/*\", '!dll', '!dll/*']\n        }),  \n      ]\n   ")]),r("p",[e._v("4. webpack.config.js中使用资源清单")]),r("p",[e._v("通过webpack.DllReferencePlugin插件使用生成的资源清单，供正常打包的时候webpack能够根据清单 不打包清单中的文件 ")]),r("pre",{staticClass:"code"},[e._v('      module.exports = {\n        plugins:[\n          new webpack.DllReferencePlugin({\n            manifest: require("./dll/jquery.manifest.json")\n          }),\n          new webpack.DllReferencePlugin({\n            manifest: require("./dll/lodash.manifest.json")\n          })\n        ]\n      }\n   ')]),r("p",[e._v("5. package.json中配置打包命令")]),r("p",[e._v("通过npm run dll执行根据指定配置文件进行打包")]),r("pre",{staticClass:"code"},[e._v(' \n     "scripts": {\n        "dll": "webpack --config webpack.dll.config.js"\n      },\n   ')]),r("p",[e._v("注意： ")]),r("p",[e._v("1.资源清单不参与运行，可以不放在dist目录下")]),r("p",[e._v("2.在html页面中需要手动引入单独打包的文件")]),r("p",[e._v("3.不要对小型的包进行分包处理")]),r("p",[e._v("4.如果是第三方库可以通过CDN引入，无需手动分包")]),r("p",[e._v("优点：")]),r("p",[e._v("1.提高了打包速度")]),r("p",[e._v("2.提高了网络响应速度")]),r("p",[e._v("3.有利于浏览器缓存")]),r("p",[e._v("缺点：")]),r("p",[e._v("1.配置繁琐")]),r("p",[e._v("2.复杂的依赖关系模块操作比较繁琐")]),r("p",[e._v("打包结果")]),r("p",[e._v("先运行单独打包的命令npm run dll")]),r("p",[e._v("再运行项目打包的命令npm run build")]),r("img",{attrs:{src:p("2369"),alt:""}}),r("h2",[e._v("3. 运行性能")]),r("p",[e._v("编写高效的代码")])])}],a={metaInfo:{title:"性能优化",meta:[{name:"性能优化",content:"性能优化"}],link:[{rel:"性能优化",href:""}]}},l=a,s=p("e90a"),v=Object(s["a"])(l,r,t,!1,null,null,null);n["default"]=v.exports},"65cb":function(e,n,p){e.exports=p.p+"img/rerend2.c40f8323.png"},"9aa9":function(e,n,p){e.exports=p.p+"img/prerend.40f759c8.png"},"9cbd":function(e,n,p){e.exports=p.p+"img/cache.e56e5a8f.png"},d443:function(e,n,p){"use strict";p.r(n);var r=function(){var e=this,n=e.$createElement,p=e._self._c||n;return p("div",[e._v(" 1-1 ")])},t=[],a={},l=a,s=p("e90a"),v=Object(s["a"])(l,r,t,!1,null,null,null);n["default"]=v.exports}}]);
//# sourceMappingURL=function1.fabc4e2e.js.map