<template>
  <div>
    <h2>js垃圾回收机制</h2>
    <pre>
      <h4>什么是内存泄漏？</h4>
        由于错误导致程序未能释放已经不再使用的内存

      <h4>内存泄漏造成的问题？</h4>
        内存泄漏越来越多，导致占用的内存越来越高，从而影响性能，和导致内存崩溃

      <h4>js中的垃圾回收机制</h4>
        js具有自动的垃圾回收机制，垃圾回收器会定期的去寻找那些不再使用的变量，然后释放其内存

        两种实现方式：
          1. 标记清除
          2. 引用计数

      <h4>标记清除</h4>
        * 垃圾收集器会给内存中所有的变量加上标记
        * 会把环境中的变量和环境中变量引用的其他变量的标记去除掉
        * 再次被标记的变量就被视为要释放的变量(进去执行环境的变量标记为进入环境，离开执行环境的变量标记为离开环境)
        * 垃圾回收器定期进行释放要释放的变量

      <h4>引用计数</h4>
        * 变量没有引用其他对象，那么它的引用就是0，会被垃圾回收器释放
        * 变量引用了其他对象，那么它的引用就是1，不会被垃圾回收器释放

        var o = {
          a: {
            b:2
          }
        };
        // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
        // 很显然，没有一个可以被垃圾收集


        var o2 = o; // o2变量是第二个对“这个对象”的引用

        o = 1;      // 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有

        var oa = o2.a; // 引用“这个对象”的a属性
                      // 现在，“这个对象”有两个引用了，一个是o2，一个是oa

        o2 = "yo"; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
                  // 但是它的属性a的对象还在被oa引用，所以还不能回收

        oa = null; // a属性的那个对象现在也是零引用了
                  // 它可以被垃圾回收了   通常需要手动释放

        缺点：
          如果两个对象循环引用，那么就一直不能进行释放，因此现在浏览器大多都是采用标记清除法

    </pre>

  </div>
</template>

<script>
export default {

}
</script>

<style>

</style>