(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["function1","home"],{"15e3":function(e,n,p){"use strict";p.r(n);var t=function(){var e=this,n=e.$createElement;e._self._c;return e._m(0)},s=[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",[t("h1",[e._v("单页面首屏加载慢和SEO问题")]),t("p",[e._v("可以使用以下方案")]),t("h2",[e._v("1. prerender-span-plugin预渲染插件")]),t("p",[e._v("prerender-span-plugin预渲染插件，就是在打包的时候根据指定的路由，把路由对应的页面渲染为html输出， 那么指定多少路由打包的时候就输出多少html页面，生成了html页面相当于原生h5，浏览器直接从服务端获取 相应的html，从而降低了首屏的显示时间 ")]),t("h3",[e._v("原理：")]),t("p",[e._v("prerender-span-plugin是利用了Chrome推出的Puppeteer库，进行页面的爬取。Puppeteer是一个Node库， 默认为headless模式(无头模式)，在无需UI的情况下通过 DevTools 协议控制Chrome;在webpack构建阶段的 最后，在本地启动Puppeteer服务，然后根据指定的预渲染路由，将相应的页面输出到html文件中，并建立相应的目录 ")]),t("img",{attrs:{src:p("9aa9"),alt:"prerender-span-plugin"}}),t("h3",[e._v("使用:")]),t("p",[e._v("前提条件，vue的路由必须使用history模式")]),t("p",[e._v("安装")]),t("pre",{staticClass:"code"},[e._v("        cnpm i -D prerender-span-plugin\n    ")]),t("p",[e._v("配置webpack.config.js")]),t("pre",[e._v("        const PrerenderSPAPlugin = require('prerender-spa-plugin')\n        const Renderer = PrerenderSPAPlugin.PuppeteerRenderer\n        plugins: [\n            new PrerenderSPAPlugin({\n                staticDir: path.join(__dirname, 'dist'),  // 注意路径不能错\n                // indexPath: path.join(__dirname, '../dist', 'index.html'), \n                routes: ['/', '/summary','/babel','/performance','/postcss','/prerenderSpaPlugin'],\n                renderer: new Renderer({\n                    inject: {\n                        foo: 'bar'\n                    },\n                    headless: true, \n                    renderAfterDocumentEvent: 'render-active' \n                    // renderAfterElementExists: '.container', \n                    // renderAfterTime: 5000 \n                })\n            })\n        ]\n    ")]),t("p",[e._v("staticDir：预渲染之后文件输出目录")]),t("p",[e._v("indexPath: 静态模板页面")]),t("p",[e._v("routes: 预渲染的路由")]),t("p",[e._v("renderer: 渲染器")]),t("p",[e._v("inject: 像预渲染页面注入数据，默认挂在window.__PRERENDER_INJECTED对象上，可以通过window.__PRERENDER_INJECTED.foo在预渲染页面取值")]),t("p",[e._v("headless：是否是无浏览器窗口")]),t("p",[e._v("renderAfterDocumentEvent： 等到指定的事件触发之后再去进行预渲染")]),t("p",[e._v("renderAfterElementExists: 在指定元素渲染之后再去触发预渲染")]),t("p",[e._v("renderAfterTime: 指定时间之后进行预渲染")]),t("p",[e._v("配置main.js")]),t("pre",{staticClass:"code"},[e._v("        new Vue({\n            router,\n            store,\n            render: h => h(App),\n            mounted(){ // vue页面挂载之后进行预渲染 \n                document.dispatchEvent(new Event('render-active'))\n            }\n        }).$mount('#app')\n    ")]),t("h2",[e._v("缺点：")]),t("p",[e._v("1. 因为是根据路由生成html,所以对于动态的路由是不起作用")]),t("p",[e._v("2. 并且不能有同名路由，否则最终只生成一个对应路由的html")]),t("h2",[e._v("优化SEO")]),t("p",[e._v("通过vue-meta-info插件进行SEO优化，一般和prerender-span-plugin预渲染插件配合使用")]),t("h3",[e._v("原理：")]),t("p",[e._v("根据配置的metaInfo，会在相应的页面中动态的创建title、meta和link元素")]),t("h3",[e._v("使用：")]),t("p",[e._v("安装")]),t("pre",[e._v("        cnpm i -D vue-meta-info\n    ")]),t("p",[e._v("配置main.js")]),t("pre",[e._v("        import MetaInfo from 'vue-meta-info' \n        Vue.use(MetaInfo)  // 使用meta\n    ")]),t("p",[e._v("组件中使用")]),t("pre",[e._v("        export default {\n            metaInfo: {   // 使用vue-meta-info插件\n                title: '性能优化', // set a title\n                meta: [{                 // set meta\n                    name: '性能优化',\n                    content: '性能优化'\n                }],\n                link: [{                 // set link\n                    rel: '性能优化',\n                    href: this.href  // 动态配置\n                }]\n            }\n        }\n    ")]),t("p",[e._v("输出结果：")]),t("img",{attrs:{src:p("65cb"),alt:""}})])}],r={},a=r,l=p("e90a"),i=Object(l["a"])(a,t,s,!1,null,"a34291e2",null);n["default"]=i.exports},"20aa":function(e,n,p){"use strict";p.r(n);var t=function(){var e=this,n=e.$createElement;e._self._c;return e._m(0)},s=[function(){var e=this,n=e.$createElement,p=e._self._c||n;return p("div",[p("h1",[e._v("babel总结")]),p("h2",[e._v("原因：")]),p("p",[e._v("不同浏览器中对最新标准的es支持度不尽相同，相同浏览器的不同版本支持度也不相同，因此为了开发者能够使用最新的标准 语法去兼容所有主流浏览器，就出现了babel ")]),p("h2",[e._v("原理：")]),p("p",[e._v("babel和webpack、postcss一样，仅仅提供代码的分析，真正的转换是借助于插件完成")]),p("h3",[e._v("1.babel的安装")]),p("p",[e._v("安装两个库")]),p("p",[e._v("- @babel/core: babel的核心库，提供了编译时需要的所有api")]),p("p",[e._v("- @bale/cli: babel命令行工具")]),p("p",[e._v("npm i -D @babel/core @babel/cli")]),p("h3",[e._v("2. babel的使用")]),p("p",[e._v("- 按文件编译")]),p("p",[e._v(" babel 要编译的文件 -o 编译结果的文件")]),p("p",[e._v("- 按目录编译")]),p("p",[e._v(" babel 要编译的目录 -o 存放编译结果的目录")]),p("h3",[e._v("3. babel的配置")]),p("p",[e._v("babel和postcss一样，既有预设又有插件(预设就是一些常用的插件的集合)")]),p("p",[e._v("根目录创建一个.babelrc的文件，配置如下代码")]),p("pre",{staticClass:"code"},[e._v('        {\n            "presets": [],  // 预设\n            "plugins": []   // 插件\n        }\n    ')]),p("h2",[e._v(" bale预设")]),p("p",[e._v("常见的预设有@babel/preset-env,可以使用最新标准的es语法，无语安装额外的插件")]),p("p",[e._v("配置如下：")]),p("pre",{staticClass:"code"},[e._v('        {\n            "presets": [\n                "@babel/preset-env"\n            ]\n        }\n    ')]),p("p",[e._v("预设的使用需要指明兼容的浏览器")]),p("p",[e._v("和postcss一样，需要创建.browserslistrc文件来描述兼容的浏览器范围")]),p("pre",{staticClass:"code"},[e._v("        last 3 version\n        > 1%\n        no ie <= 8\n    ")]),p("p",[e._v("给预设设置自身的配置")]),p("p",[e._v("常见的配置有useBuiltIns,预设仅仅转换新的语法并不会对新的api进行转换,默认是false, 不能够使用最新的Esapi,可以设置为usage ")]),p("pre",{staticClass:"code"},[e._v('        {\n            "presets": [\n                ["@babel/preset-env",{\n                    "useBuiltIns": \'usage\',\n                    "corejs": 3  // 指定corejs的版本\n                }]  \n            ]\n        }\n    ')]),p("h2",[e._v("babel插件")]),p("p",[e._v("条件：比预设更加广泛，预设只能转换已经形成标准的es语法，对于提案的和最新的非标准Es语法还是不能够转换")]),p("p",[e._v("安装core-js和pregenerator-runtime插件可以使用最新的esapi,比如promise,asncy等")]),p("p",[e._v("core-js: 提供转换的api")]),p("p",[e._v("pregenerator-runtime: 用于转换generator迭代器")]),p("p",[e._v("1. babel-plugin-transform-remove-console")]),p("p",[e._v("打包的时候删除js中的所有console")]),p("pre",{staticClass:"code"},[e._v('        {\n            "plugins": [\n                [\n                "babel-plugin-transform-remove-console"\n                ]\n            ]\n            }\n    ')])])}],r={},a=r,l=p("e90a"),i=Object(l["a"])(a,t,s,!1,null,null,null);n["default"]=i.exports},2369:function(e,n,p){e.exports=p.p+"img/fb.d7f2e4bf.png"},5038:function(e,n,p){"use strict";p.r(n);var t=function(){var e=this,n=e.$createElement;e._self._c;return e._m(0)},s=[function(){var e=this,n=e.$createElement,p=e._self._c||n;return p("div",[p("h1",[e._v("React Router之登录鉴权")]),p("h3",[e._v("解决的问题：")]),p("p",[e._v("用户没有登录的时候只能进入特定的几个页面，当用户想要进入详情界面就需要用户登录之后才能进入")]),p("h3",[e._v("个人解决方案有两种")]),p("h4",[e._v("方案一：")])])}],r={},a=r,l=p("e90a"),i=Object(l["a"])(a,t,s,!1,null,"0ad8048e",null);n["default"]=i.exports},5312:function(e,n,p){"use strict";p.r(n);var t=function(){var e=this,n=e.$createElement;e._self._c;return e._m(0)},s=[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",[t("h1",[e._v("性能优化")]),t("p",[e._v("性能优化主要从以下几个方面入手：")]),t("p",[e._v("1. 构建性能")]),t("p",[e._v("2. 传输性能")]),t("p",[e._v("3. 运行性能")]),t("h2",[e._v("1. 构建性能")]),t("p",[e._v("构建性能是指:从打包开始到打包完毕或者从修改之后点击保存自动打包到页面的更新过程,整个过程都是在开发阶段进行的")]),t("p",[e._v("开发阶段优化了构建性能，可以大大的提高打包速度，从而提升了开发效率")]),t("p",[e._v("构建性能主要可以从以下几个方面考虑：")]),t("h3",[e._v("1.1 减少模块解析")]),t("p",[e._v("webpack中模块解析包括：抽象语法树分析、依赖分析、模块语法替换")]),t("h4",[e._v("不进行解析的模块会怎样？")]),t("p",[e._v("不做解析的模块，在loader处理之后就直接输出")]),t("p",[e._v("不做解析的模块，就少了上面的步骤，从而提升了打包速度")]),t("h4",[e._v("模块不需要解析的前提条件：")]),t("p",[e._v("模块中无其他依赖，如：jquery")]),t("h4",[e._v("配置如下：")]),t("pre",[e._v("        module.exports = {\n            //...\n            module: {\n                noParse: /jquery|lodash/,  // 不解析jqery和loadsh\n            }\n        };\n   ")]),t("h3",[e._v("1.2 loader方面的优化")]),t("h4",[e._v("1.2.1 让一些文件不使用loader")]),t("p",[e._v("减少loader的使用可以让一些文件不走loader转换，从而提高了打包速度")]),t("p",[e._v("有些文件或者第三方库本来就是loader转换之后的内容，所以就不需要loader再次解析")]),t("p",[e._v("eg:使用es5或者es3写了一个js文件，或者第三库本来就是使用es5写的代码，所以肯本不再需要 babel-loader进行转换，所以如下设置去除此文件的解析 ")]),t("pre",{staticClass:"code"},[e._v('      module.exports = {\n          module: {\n              rules: [\n                  {\n                      test: /\\.js$/,\n                      exclude: /node_modules/,  // 不解析node_modules\n                      //或\n                      // include: /src/,  // 指解析src文件夹下的文件\n                      use: "babel-loader"\n                  }\n              ]\n          }\n      }\n   ')]),t("h4",[e._v("1.2.2 缓存loader")]),t("p",[e._v("如果一些文件或者第三方库的内容在loader转换之后就不再改变，那么就可以在第一次编译之后进行缓存，以后的 每次打包都直接从缓存中获取 ")]),t("p",[e._v("eg: 对于jquery或者其他的第三方库")]),t("p",[e._v("使用cache-loader进行缓存")]),t("p",[e._v("安装")]),t("p",[e._v("npm install --save-dev cache-loader")]),t("p",[e._v("配置")]),t("pre",[e._v("    module.exports = {\n      module: {\n        rules: [\n          {\n            test: /jquery\\.js$/,\n            use: [ {\n              loader: 'cache-loader',\n              options:{\n                cacheDirectory: \"./cache\" // 指定缓存到的目录\n              }\n            }, 'babel-loader']\n          },\n        ],\n      },\n    };\n   ")]),t("p",[e._v("原理：")]),t("p",[e._v("匹配到文件之后，走loader的pitch方法，如果pitch方法发现有缓存就返回缓存中的代码，否则就走loader进行解析")]),t("img",{attrs:{src:p("9cbd"),alt:""}}),t("h4",[e._v("1.2.3 使用thread-loader给loader开启线程池")]),t("p",[e._v("把loader放到线程池中的线程中，以便提高构建速度")]),t("p",[e._v("放入线程池中的loader不能使用以下功能")]),t("p",[e._v("- 不能够使用webpack api")]),t("p",[e._v("- 无法访问webpack options")]),t("p",[e._v("- 无法使用自定义的plugin api")]),t("p",[e._v("注意，开启和管理线程需要消耗时间，在小型项目中使用thread-loader反而会增加构建时间")]),t("h4",[e._v("1.2.4 使用热更新")]),t("p",[e._v("热更新并不能降低构建的时间，可能会增加，但是减少了从更改代码保存到页面呈现的时间")]),t("p",[e._v("配置")]),t("p",[e._v("webpack.config.js")]),t("pre",{staticClass:"code"},[e._v("      const webpack = require('webpack');\n      module.exports = {\n        devServer:{\n          hot:true // 开启热更新\n        },\n        plugins:[ \n          // 使用热更新插件\n          new webpack.HotModuleReplacementPlugin()\n        ]\n      }\n   ")]),t("p",[e._v("入口文件中")]),t("pre",{staticClass:"code"},[e._v("      if(module.hot){ // 是否开启了热更新\n          module.hot.accept() // 接受热更新\n      }\n   ")]),t("p",[e._v("基本流程")]),t("p",[e._v("在没有使用热更新的时候，每次编译运行，webpack-dev-server都会执行localtion.reload重新加载页面，当使用了 热更新之后，webpack-dev-server会通过websocket把变更的代码主动推送到浏览器，然后通过注入的module.hot.accept进行接收， 然后通过HotModuleReplacementPlugin插件覆盖之前的模块并执行,所以热更新发生在代码运行期 ")]),t("p",[e._v("1. 修改一个或者多个文件中的代码")]),t("p",[e._v("2. webpack重新编译构建变更的模块,并通知HMR服务器进行更新")]),t("p",[e._v("3. HMR服务器通过websocket推送变更的模块到客户端")]),t("p",[e._v("4. 客户端通过注入的module.hot.accept接收到变更的内容")]),t("p",[e._v("5. HotModuleReplacementPlugin插件替换更新的模块进行执行")]),t("p",[e._v("6. 如果这些模块无法执行那么就直接执行localtion.reload重新加载页面")]),t("p",[e._v("注意：")]),t("p",[e._v("样式也可以进行热更新，但是通过mini-css-extract-plugin插件生成单独文件的样式不能进行热更新，因为 热更新发生在代码运行时期，而mini-css-extract-plugin插件生成单独css文件发生在构建时期,style-loader 的样式是可以进行热更新 ")]),t("h2",[e._v("2. 传输性能")]),t("p",[e._v("传输性能是指：文件从服务端传输到客户端的过程所需要的时间")]),t("p",[e._v("传输性能的提升可以缩短从页面请求到呈现的时间，可以从以下几个方面考虑：")]),t("p",[e._v(" - 总传输量：将所有的传输文件内容都加起来就是总传输")]),t("p",[e._v(" - 文件数量：需要传输的所有文件数量 ")]),t("p",[e._v(" - 浏览器缓存： 通过设置可以使得浏览器缓存传输的文件，被缓存的文件再次获取就会从缓存中获取")]),t("h3",[e._v("2.1 打包之后包太大可以分包处理")]),t("p",[e._v("解决的问题：")]),t("p",[e._v("一个文件包太大，导致网络响应很慢")]),t("p"),t("h4",[e._v(" 2.1.1 手动分包")]),t("p",[e._v("基本思路：")]),t("p",[e._v("- 单独的打包公共模块")]),t("p",[e._v("- 公共模块会被打包成动态链接库，并生成资源清单")]),t("p",[e._v("- 根据入口模块进行正常的打包")]),t("p",[e._v("- 在html页面中手动引入单独打包的公共模块")]),t("p",[e._v("步骤：")]),t("p",[e._v("1. 创建webpack.dll.config.js文件")]),t("p",[e._v("用于配置要单独打包的文件，暴露出变量名在全局中")]),t("pre",{staticClass:"code"},[e._v('      // 手动单独打包的配置\n      module.exports = {\n          mode: "production",\n          entry: { // 需要单独打包的文件\n              jquery: ["jquery"],\n              lodash: ["lodash"]\n          },\n          output: {\n              filename: "dll/[name].js",\n              library: "[name]" // 打包之后暴露的变量名\n          },\n          plugins: [\n              // 生成资源清单\n              new webpack.DllPlugin({\n                  path: path.resolve(__dirname,"dll","[name].manifest.json"), // 资源清单保存的位置\n                  name: "[name]" // 资源清单中，暴露的变量名\n              })\n          ]\n      }\n   ')]),t("p",[e._v("2. html页面手动引入单独的打包文件")]),t("img",{attrs:{src:p("8119"),alt:""}}),t("p",[e._v("3. webpack.config.js中设置clean-webpack-plugin插件")]),t("p",[e._v("如果使用了clean-webpack-plugin这个插件就需要重新配置，防止每次打包都清空了单独打包的文件")]),t("pre",{staticClass:"code"},[e._v("      plugins: [ // 插件\n        new CleanWebpackPlugin({ // 打包前清空目录\n            // 排除掉dll目录本身和它里面的文件\n            cleanOnceBeforeBuildPatterns: [\"**/*\", '!dll', '!dll/*']\n        }),  \n      ]\n   ")]),t("p",[e._v("4. webpack.config.js中使用资源清单")]),t("p",[e._v("通过webpack.DllReferencePlugin插件使用生成的资源清单，供正常打包的时候webpack能够根据清单 不打包清单中的文件 ")]),t("pre",{staticClass:"code"},[e._v('      module.exports = {\n        plugins:[\n          new webpack.DllReferencePlugin({\n            manifest: require("./dll/jquery.manifest.json")\n          }),\n          new webpack.DllReferencePlugin({\n            manifest: require("./dll/lodash.manifest.json")\n          })\n        ]\n      }\n   ')]),t("p",[e._v("5. package.json中配置打包命令")]),t("p",[e._v("通过npm run dll执行根据指定配置文件进行打包")]),t("pre",{staticClass:"code"},[e._v(' \n     "scripts": {\n        "dll": "webpack --config webpack.dll.config.js"\n      },\n   ')]),t("p",[e._v("注意： ")]),t("p",[e._v("1.资源清单不参与运行，可以不放在dist目录下")]),t("p",[e._v("2.在html页面中需要手动引入单独打包的文件")]),t("p",[e._v("3.不要对小型的包进行分包处理")]),t("p",[e._v("4.如果是第三方库可以通过CDN引入，无需手动分包")]),t("p",[e._v("优点：")]),t("p",[e._v("1.提高了打包速度")]),t("p",[e._v("2.提高了网络响应速度")]),t("p",[e._v("3.有利于浏览器缓存")]),t("p",[e._v("缺点：")]),t("p",[e._v("1.配置繁琐")]),t("p",[e._v("2.复杂的依赖关系模块操作比较繁琐")]),t("p",[e._v("打包结果")]),t("p",[e._v("先运行单独打包的命令npm run dll")]),t("p",[e._v("再运行项目打包的命令npm run build")]),t("img",{attrs:{src:p("2369"),alt:""}}),t("h4",[e._v(" 2.1.2 自动分包")]),t("p",[e._v("自动分包不像手动分包那样指定具体的分包文件，只需要配置下分包策略，webpack会自动根据分包策略进行分包")]),t("p",[e._v("webpack内部默认具有自动分包的优化配置，实际上内部使用了splitChunksPlugin进行分包，过去使用的是CommonsChunkPlugin插件进行分包，由于 它不完善所以被splitChunksPlugin取代,我们可以更改配置达到我们自身的要求")]),t("p",[e._v("基本流程:")]),t("p",[e._v("- 配置分包策略")]),t("p",[e._v("- 分局分包策略，webpack开启一个chunk，对分离的模块进行打包")]),t("p",[e._v("分别策略基本配置：")]),t("p",[e._v("webpack提供了optimization配置项，用于配置一些优化信息")]),t("p",[e._v("其中splitChunks是分包策略的配置")]),t("pre",{staticClass:"code"},[e._v("      module.exports = {\n        optimization: {  // 优化方面的配置项\n            splitChunks:{  // 自动分包的配置\n                // 配置项\n            }\n        }\n      }\n    ")]),t("p",[e._v("配置项")]),t("p",[e._v("1.chunks")]),t("p",[e._v("配置需要应用分包策略的chunk")]),t("p",[e._v("all: 对所有的chunk都要应用分包策略")]),t("p",[e._v("async:(默认)对异步的chunk应用分包策略")]),t("p",[e._v("inital: 对普通的chunk进行分包策略")]),t("p",[e._v("2. maxSize")]),t("p",[e._v("控制一个包的最大字节数，如果超过了指定的大小，那么就尽可能的进行分割成多个包，但是webpack的分包基础单位是 模块。如果一个完整的模块超过了这个指定的大小，webpack是无法再进行分割的，因此即使配置了这个属性，有时候还是 达不到分包的效果。 ")]),t("p",[e._v("使用此项的意义不大，因为分包的目的是提取公共的代码，减少文件大小和传输量，使用此项将大包进行分割成多个包，然后 体积并没有变化，只是减少了单个包的体积，网络下载的时候可以并行下载 ")]),t("p",[e._v("如果想要进一步减少包的体积，只能压缩代码和tree shaking")]),t("p",[e._v("3. automaticNameDelimiter")]),t("p",[e._v("新chunk的分割符，默认是~")]),t("p",[e._v("4. minChunks")]),t("p",[e._v("一个模块被多少个chunk使用的时候才进行分包，默认是1")]),t("p",[e._v("5. minSize")]),t("p",[e._v("当包的大小最少为多少个字节才进行分包，默认30000")]),t("p",[e._v("6. maxInitialRequests")]),t("p",[e._v("允许入口并行加载得最大请求数量，如果超出了这个数量，即使后面的包满足分包策略也不进行分包了，之所以有这个配置也是为了对拆分数量进行限制，不至于拆分出太多模块导致请求数量过多而得不偿失。")]),t("p",[e._v("注意:")]),t("p",[e._v("入口文件本身算一个请求")]),t("p",[e._v("如果入口里面有动态加载得模块这个不算在内")]),t("p",[e._v("通过runtimeChunk拆分出的runtime不算在内")]),t("p",[e._v("只算js文件的请求，css不算在内")]),t("p",[e._v("如果同时又两个模块满足cacheGroup的规则要进行拆分，但是maxInitialRequests的值只能允许再拆分一个模块，那尺寸更大的模块会被拆分出来")]),t("p",[e._v("7. maxAsyncRequests")]),t("p",[e._v("maxAsyncRequests和maxInitialRequests有相似之处，它俩都是用来限制拆分数量的，maxInitialRequests是用来限制入口的拆分数量而maxAsyncRequests是用来限制异步模块内部的并行最大请求数的，说白了你可以理解为是每个import()它里面的最大并行请求数量。")]),t("p",[e._v("这其中要注意以下几点：")]),t("p",[e._v("1、import()文件本身算一个请求")]),t("p",[e._v("2、并不算js以外的公共资源请求比如css")]),t("p",[e._v("3、如果同时有两个模块满足cacheGroup的规则要进行拆分，但是maxInitialRequests的值只能允许再拆分一个模块，那尺寸更大的模块会被拆分出来")]),t("p",[e._v("8. cacheGroups(缓存组)")]),t("p",[e._v("其中的每一项缓存组都可以继承/覆盖之前提到的 splitChunks 参数值（如 name、maxSize、minSize、maxInitialRequests、maxAsyncRequests 等），除此之外还额外提供了三个配置，分别为：test, priority 和 reuseExistingChunk。")]),t("p",[e._v("test: 表示要过滤 modules，默认为所有的 modules，可匹配模块路径或 chunk 名字，当匹配到某个 chunk 的名字时，这个 chunk 里面引入的所有 module 都会选中；")]),t("p",[e._v("priority：权重，数字越大表示优先级越高。一个 module 可能会满足多个 cacheGroups 的正则匹配，到底将哪个缓存组应用于这个 module，取决于优先级；")]),t("p",[e._v("reuseExistingChunk：表示是否使用已有的 chunk，true 则表示如果当前的 chunk 包含的模块已经被抽取出去了，那么将不会重新生成新的，即几个 chunk 复用被拆分出去的一个 module；")]),t("p",[e._v("除了上面的的属性，缓存组还有两个属性——filename 和 enforce：")]),t("p",[e._v("filename: 这个属性会覆盖 output.filename 这个属性，前提是 chunks 设为 initial。同时，这个属性也能全局设置，比如 splitChunks.filename，但是如果 chunks 设为非 initial，webpack 将会报错，所以官方建议这个属性不全局设置。")]),t("p",[e._v("enforce: 布尔类型，默认为 false。当设为 true 时，webpack 会忽略 splitChunks.minSize、splitChunks.minChunks、splitChunks.maxAsyncRequests、splitChunks.maxInitialRequests 这几个配置项，并且只要某个缓存组设置了 enforce 为 true， 匹配的模块就会忽略前面提到的那几个属性，即使有其他的缓存组匹配同样的模块，也没有设置 enforce，同时优先级比设置了 enforce 的高，enforce: true 仍然有效。")]),t("p",[e._v("缓存组可以对Css进行分包")]),t("pre",{staticClass:"code"},[e._v("      module.exports = {\n        mode: \"production\",\n        optimization: {  // 优化方面的配置项\n            splitChunks:{  // 自动分包的配置\n                chunks: 'all', // 所有的chunk都应用分包策略\n                minSize: 30000,  // 最小包为30kb才进行分包\n                minChunks: 1,    // 最少被引用过一次\n                maxAsyncRequests: 5,   // 限制异步模块内部的并行最大请求数\n                maxInitialRequests: 3, // 允许入口并行加载的最大请求数 超过了这个数量就不再继续分包了即使满足分包策略\n                automaticNameDelimiter: '~',\n                name: true, \n                cacheGroups: { // 缓存组 默认有两个vendors和default，继承上面的配置，如果有相同配置会覆盖\n                  vendors: { \n                    test: /[\\/]node_modules[\\/]/, // 从指定的文件中进行匹配\n                    priority: -10 // 优先级，值越大优先级越高\n                  },\n                  default: {\n                    minChunks: 2,  // 最少被其他模块引用次数\n                    priority: -20, // 优先级\n                    reuseExistingChunk: true  // 重用已经被分离出去的chunk\n                  },\n                  styles: { // 利用缓存组对css进行分包\n                    test: /\\.css$/, // 匹配样式模块\n                    minSize: 0, // 覆盖默认的最小尺寸，这里仅仅是作为测试\n                    minChunks: 2 // 覆盖默认的最小chunk引用数\n                  } \n                },\n            }\n        }\n      }\n    ")]),t("p",[e._v("多页应用自动引入分包后的chunk")]),t("p",[e._v("目前版本的htmlWebpackPlugin不能够自动引入分包之后的公共chunk,但是它的下个版本会支持这个功能 因此可以提前使用它的@next版本 ")]),t("p",[e._v("安装:")]),t("pre",{staticClass:"code"},[e._v("npm i -D html-webpack-plugin@next")]),t("p",[e._v("配置")]),t("pre",{staticClass:"code"},[e._v('      new HtmlWebpackPlugin({\n        template: "./public/index.html",\n        chunks: ["index"]\n      })\n    ')]),t("p",[e._v("它会自动的找到被index分离出去的chunk，并完成引用")]),t("h5",[e._v("原理：")]),t("p",[e._v("1. 检查每个chunk编译的结果")]),t("p",[e._v("2. 根据分包策略找到满足条件的模块")]),t("p",[e._v("3. 新生成的chunk对找出的模块进行打包")]),t("p",[e._v("4. 把打包出来的模块从原码中移除")]),t("h4",[e._v("3. 压缩代码")]),t("p",[e._v("作用：")]),t("p",[e._v(" 减少代码的体积，破坏代码的可读性，提升代码的破解成本 ")]),t("p",[e._v(" 代码压缩工具 ")]),t("p",[e._v("1. UglifyJs")]),t("p",[e._v("UglifyJs不支持es6所以被使用的越来越少")]),t("p",[e._v("2. Terser")]),t("p",[e._v("新一代的压缩代码工具，支持es6+,因为被很多构建工具内置使用，webpack安装后就会内置Terser,当启用生产环境 就会自动进行代码压缩 ")]),t("p",[e._v("webpack自动集成了Terser,可以通过如下配置进行添加其他压缩工具")]),t("pre",{staticClass:"code"},[e._v("      const TerserPlugin = require('terser-webpack-plugin');\n      const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');\n      module.exports = {\n        optimization: {\n          // 是否要启用压缩，默认情况下，生产环境会自动开启\n          minimize: true, \n          minimizer: [ // 压缩时使用的插件，可以有多个\n            new TerserPlugin(), \n            new OptimizeCSSAssetsPlugin()\n          ],\n        },\n      };\n    ")]),t("h4",[e._v("4. tree shaking")]),t("p",[e._v("压缩移除掉模块中无效的代码，没有被使用的代码")]),t("p"),t("h2",[e._v("3. 运行性能")]),t("p",[e._v("编写高效的代码")])])}],r={metaInfo:{title:"性能优化",meta:[{name:"性能优化",content:"性能优化"}],link:[{rel:"性能优化",href:""}]}},a=r,l=p("e90a"),i=Object(l["a"])(a,t,s,!1,null,null,null);n["default"]=i.exports},"65cb":function(e,n,p){e.exports=p.p+"img/rerend2.c40f8323.png"},8119:function(e,n,p){e.exports=p.p+"img/fb2.3fde9684.png"},"9aa9":function(e,n,p){e.exports=p.p+"img/prerend.40f759c8.png"},"9cbd":function(e,n,p){e.exports=p.p+"img/cache.e56e5a8f.png"},d443:function(e,n,p){"use strict";p.r(n);var t=function(){var e=this,n=e.$createElement,p=e._self._c||n;return p("div",[e._v(" 1-1 ")])},s=[],r={},a=r,l=p("e90a"),i=Object(l["a"])(a,t,s,!1,null,null,null);n["default"]=i.exports}}]);
//# sourceMappingURL=function1.4f6e9f49.js.map